---

alwaysApply: true
description: >
Expert Next.js, React, and TypeScript coding standards for producing optimized,
maintainable, and scalable code following clean architecture principles.
rules:

- id: nextjs-architecture
  description: >
  Maintain a modular, feature-based Next.js architecture with a clear folder structure.
  details: |
  • Follow a feature-based folder organization for scalability and clarity.  
   • Use functional and declarative programming; avoid classes.  
   • Prefer small, composable components over repetition.  
   • Use descriptive variable names (e.g., `isLoading`, `hasError`).  
   • Directory conventions: - `components/ui/` → Shadcn UI or Radix UI components only.
  - `components/[feature]/` → Custom or manual feature-based components.
  - `types/[feature]/` → Feature-specific TypeScript interfaces, enums, and types.
  - `utils/[feature]/` → Feature-based helper and utility methods.
  - `hooks/[feature]/` → Custom feature-based React hooks.
  - `lib/` → Server utilities, configs, constants, and API logic.  
    • Use lowercase with dashes for folder names (e.g., `components/auth-wizard`).  
    • Always move: - TypeScript types → `types/`
  - Helper methods → `utils/`

- id: import-optimization
  description: >
  Keep imports clean, minimal, and optimized for bundle size.
  details: |
  • Always import lodash functions individually for tree-shaking:
  `import isEmpty from "lodash/isEmpty"`.  
   • Group imports logically: 1. External libraries  
   2. Internal modules  
   3. Styles or assets  
   • Remove unused imports automatically and sort consistently.

- id: performance-and-optimization
  description: >
  Optimize Next.js code for performance, scalability, and fast UI rendering.
  details: |
  • Avoid excessive `'use client'`, `useEffect`, and `setState`.  
   • Favor React Server Components (RSC), SSR, or ISR wherever possible.  
   • For client-side components: - Use dynamic imports (`next/dynamic`) to improve load performance and UI interactivity.
  - Always provide a loading fallback for dynamic components.  
    • Follow a mobile-first responsive design approach.  
    • Optimize images: - Use WebP format
  - Include width and height metadata
  - Enable lazy loading (`loading="lazy"`)

- id: error-handling-and-validation
  description: >
  Implement consistent and robust error handling and validation.
  details: |
  • Use guard clauses and early returns for invalid states.  
   • Define custom error classes for consistent error propagation.  
   • Use Zod for schema validation (input, forms, and API responses).  
   • Handle async/await with try/catch blocks and typed errors.

- id: ui-and-styling
  description: >
  Follow modern and consistent UI/UX standards.
  details: |
  • Use Tailwind CSS, Shadcn UI, and Radix UI for styling.  
   • Keep Shadcn components isolated in `components/ui`.  
   • Maintain consistent color palette, spacing, and typography scale.  
   • Ensure accessibility (a11y) across all devices.  
   • Apply consistent responsive breakpoints.

- id: state-and-data
  description: >
  Use efficient state management and typed data fetching.
  details: |
  • Use TanStack React Query or Zustand for global state management.  
   • Implement caching and background revalidation where applicable.  
   • Use async/await and handle errors with proper type definitions.  
   • Always define interfaces or types for API responses and props in `types/[feature]`.

- id: security-and-performance
  description: >
  Maintain secure, performant, and production-ready code.
  details: |
  • Sanitize and validate all user input.  
   • Prevent XSS, CSRF, and injection vulnerabilities.  
   • Apply edge caching, code splitting, and static optimizations.  
   • Periodically audit dependencies for vulnerabilities.  
   • Use dynamic imports for better client-side performance and faster TTI (Time to Interactive).

- id: testing-and-documentation
  description: >
  Ensure the codebase is testable and well-documented.
  details: |
  • Write unit tests using Jest and React Testing Library.  
   • Add JSDoc comments for complex logic and exported utilities.  
   • Document props, hooks, and utility functions clearly.  
   • Include inline comments for edge-case logic and optimizations.

- id: development-methodology
  description: >
  Follow a structured, analytical, and iterative workflow for all implementations.
  details: |
  1. System 2 Thinking → Analytical approach; break down complex requirements.
  2. Tree of Thoughts → Explore multiple solutions and choose the optimal one.
  3. Iterative Refinement → Continuously enhance readability, performance, and maintainability.
  4. Use <PLANNING> tags before major implementations to outline structure.
  5. Finalize only after validating against performance, security, and architecture standards.
